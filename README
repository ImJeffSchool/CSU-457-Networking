# PsyDuck's Game Show Example

This is a simple Game show example implemented using Python and sockets.

# How to play:
1. **Start the server:** Run the `server.py` script. Starts a pre-game lobby, and awaits 2 players to connect and ready up. Please ensure that both players are connected before readying-up. An Example of this would look like:
"python server.py -p 54321" - Where -p is the specified port number.
2. **Connect clients:** Run the `client.py` script on two different machines or terminals. Once a player connects, they may adjust game settings and ready up. An example of this would look like:
"python client.py -i 123.45.67.89 -p 54321" - Where -i is the client's IP address and -p is the port number connecting to the server. Ensure that when connecting both clients have different IP addresses.
3. **Play the game:** Jeopardy style game where one Player will select a question from the board and given the chance to answer the question, If the first player doesn't answer the question correctly, it then goes over to the next player where they now have the chance to answer the question for points. Players take turns answering their selected questions, being awarded respective points. The game will continue to play until all questions are answered on the board. Whichever player has the most amount of points at the end will be deemed the victor.

# Message Protocol:
1. Players who get connected to the server must then ready up or quit. 
2. Messages will be defined as a JSON type scheme.
3. Various message types such as quitting and joining the game.
4. Game will have expected response messages such as getting a question right or getting a question wrong.
5. When playing the game the user will need to choose a row and column to specify a question. For example, when a user is asked to select a question they should answer as 1,1.

# File Structure:
'server.py': Handles the serverside game logic, updateing the current game state, broadcasting to players, and handling the retrieval of questions as well as validation of answers.
'client.py': Handles the clientside connection and game logic updates. The server and client each have an associated gameInstance object to ensure consistent game state for all connected players.
'Message.py': Handles the message objects for the server and client. Sends a JSON object that signals things like *ReadyUp* and *QuestionSelection.*
'Jeopardy.py': Handles the game state, keeping a list of all players and the current quesiton and answers board.
'Player.py': Handles the individual player data, things like their name, points, connected IP and port.
'Question.py': Handles our question board and points board where each row and column has their respective answers. 

# Technologies used:
* Python
* Tkinter Python GUI Library (built into base Python)
* Sockets

# Additional resources:
* Tkinter: https://docs.python.org/3/library/tkinter.html
* [Link to sockets tutorial]

Defined request JSON Schema:
{
  "type": "object",
  "properties": {
    "action": {
      "type": "string"
    },
    "value": {
      "type": "string"
    }
  },
  "required": [
    "action"
  ]
}

Defined response JSON Schema:
{
  "type": "object",
  "properties": {
    "action": {
      "type": "string"
    },
    "value": {
      "type": "string"
    }
  },
  "required": [
    "action",
    "value"
  ]
}

request JSON:
select, ready, quit, answerQuestions, 

response JSON
provideQuestion, validateAnswer, provideAnswer

# Security/Risk Evaluation:
1. Lack of Authentication - We can introduce an authentication system using usernames and passwords.
2. Lack of Data Encryption - We can implement TLS/SSL encryption for commmunication between clients and the server.
3. Potential Socket Exploits - We can add rate-limiting to limit the amount of data being sent to prevent potential flooding.
4. Hardcoded Error Messages - We can be more general about our error messages to avoid revealing unecessary details to a potential attacker.
5. Code Injection - We can implement escape mechanisms and strictly enforce handling of strings.